package models.checkout


import org.joda.money.{CurrencyUnit, Money}
import models.enums._
import org.squeryl.PrimitiveTypeMode._
import java.sql.{Connection, Timestamp}
import services.{AppConfig, Time}
import services.db._
import models._
import com.google.inject.Inject
import services.logging.Logging
import scala.Left
import scala.Some
import scala.Right
import exception.InsufficientInventoryException
import services.payment.Charge


// NOTE(SER-499): CashTransaction sets convention that payments to us are positive

/**
 * TODO: Refunds
 * -implement a product refund type and item for the purpose of canceling out its targetted
 *  item or type in the calculation of new totals (e.g. #1 above)
 *   -refunding tax could be separate or combined into product's refund amount
 * -implement a refund charge type to represent the credit made back to the customer
 */

// TODO(SER-499): most of this should not remain in pull request, just here for keeping track of noise generated by design
package object checkout {
  /** For _domainEntityId if domain object doesn't get persisted; ex: Tax */
  val UnusedDomainEntity: Long = -1

  /** For id's of line items and line item types that don't get persisted; ex: Subtotal */
  val Unpersisted: Long = -2

  val UnsavedEntity = 0

  type LineItems = Seq[LineItem[_]]
  type LineItemTypes = Seq[LineItemType[_]]
  type FailureOrCheckout = Either[Checkout.CheckoutFailed, Checkout]


  //
  // LineItems DSL conversion
  //
  implicit def lineItemSeqToMemberDSL(items: LineItems) = new {
    def subtotalOption = ofCodeType(CodeType.Subtotal).headOption
    def taxes: Seq[TaxLineItem] = ofCodeType(CodeType.Tax)
    def fees: LineItems = ofNature(LineItemNature.Fee)
    def totalOption = ofCodeType(CodeType.Total).headOption
    def payments: LineItems = ofNature(LineItemNature.Payment)

    def ofCodeType[LIT <: LineItemType[_], LI <: LineItem[_]] (codeType: CodeTypeFactory[LIT, LI]) = {
      items.flatMap(_.asCodeTypeOption(codeType))
    }

    def ofCodeTypes(codeTypes: Set[CodeType]) = items.filter(codeTypes contains _.codeType)
    def notOfCodeType(codeType: CodeType) = items.filterNot(_.codeType == codeType)
    def notofCodeTypes(codeTypes: Set[CodeType]) = items.filterNot(codeTypes contains _.codeType)

    def ofNature(nature: LineItemNature) = items.filter(_.nature == nature)
    def ofNatures(natures: Set[LineItemNature]) = items.filter(natures contains _.nature)
    def notOfNature(nature: LineItemNature) = items.filterNot(_.nature == nature)
    def notOfNatures(natures: Set[LineItemNature]) = items.filterNot(natures contains _.nature)

    def sumAmounts: Money = items.foldLeft(Money.zero(CurrencyUnit.USD)){ _ plus _.amount }
  }
}

import models.checkout.checkout._



// TODO(SER-499): look into why store isn't usually combined into services (modeling concern probs)
//
// Services
//
case class CheckoutServices @Inject() (
  schema: Schema,
  lineItemStore: LineItemStore,
  customerStore: CustomerStore,
  accountStore: AccountStore,
  addressStore: AddressStore,
  dbSession: DBSession,
  @CurrentTransaction currentTxnConnectionFactory: () => Connection
) extends InsertsAndUpdatesAsEntity[Checkout, CheckoutEntity]
  with SavesCreatedUpdated[CheckoutEntity]
{

  override protected def table = schema.checkouts

  override def modelWithNewEntity(checkout: Checkout, entity: CheckoutEntity) = checkout.copy(entity)

  override def withCreatedUpdated(toUpdate: CheckoutEntity, created: Timestamp, updated: Timestamp) = {
    toUpdate.copy(created=created, updated=updated)
  }

  def findById(id: Long): Option[Checkout] = table.lookup(id).map { entity =>
    Checkout(entity, lineItemStore.getItemsByCheckoutId(entity.id))
  }

  def getCheckoutsByCustomerId(id: Long): Seq[Checkout] = {
    val checkouts = for (
      checkoutEntity <- table.where(entity => entity.customerId === id);
      checkout <- findById(checkoutEntity.id)
    ) yield checkout

    checkouts.toSeq
  }
}





//
// Model
//
case class Checkout (
  _entity: CheckoutEntity,
  _typesOrItems: Either[LineItemTypes, LineItems],
  _customer: Option[Customer],
  pendingTypes: LineItemTypes = Nil,
  services: CheckoutServices = AppConfig.instance[CheckoutServices]
) extends HasEntity[CheckoutEntity, Long]
  with CanInsertAndUpdateAsThroughServices[Checkout, CheckoutEntity]
{
  import Checkout._

  //
  // Checkout members
  //
  lazy val lineItems: LineItems =  _typesOrItems match {
    case Right(items: LineItems) => resolveTypes(pendingTypes, items)
    case Left(types: LineItemTypes) => resolveTypes(types)
  }

  lazy val lineItemTypes: LineItemTypes = _typesOrItems match {
    case Left(types: LineItemTypes) => types
    case Right(items: LineItems) => pendingTypes ++ items.map(_.itemType)
  }

  lazy val customer: Customer = _customer.getOrElse(
    services.customerStore.findById(customerId).getOrElse(
      throw new IllegalArgumentException("No customer associated with this checkout.")
    )
  )




  // TODO: make sure this includes discounts that are becoming invalid with pending changes
  lazy val pendingItems = {
    /**
     * matches new items to old items and produces the items of the difference (or full new price
     * if no matching old item exists)
     */
    def grossToNet(newItems: LineItems, oldItems: LineItems) = newItems.flatMap { newItem =>
      val oldAmount = oldItems.find(_.itemType == newItem.itemType).map(_.amount)
        .getOrElse(Money.zero(CurrencyUnit.USD))

      if (oldAmount isGreaterThan newItem.amount) {
        None // refund item will list this difference
      } else {
        Some(newItem.withAmount(newItem.amount minus oldAmount)) // update amount to difference
      }
    }

    val pendingWithSummaries = SubtotalLineItemType +: (TotalLineItemType +: pendingTypes)
    val itemsSansSummaries = lineItems.filter(_.nature == LineItemNature.Summary)
    val allResolved = resolveTypes(pendingWithSummaries, itemsSansSummaries)

    allResolved.filter(item => pendingWithSummaries.contains(item.itemType))
  }





  def withCustomer(customer: Customer) = {
    this.copy(
      _entity = _entity.copy(customerId = customer.id),
      _customer = Some(customer))
  }


  /**
   * Adds unpersisted types to a persisted checkout (to queue up for an update) or adds to other
   * types in an unpersisted checkout.
   *
   * @param newTypes -- to be added to this checkout
   * @return If transacted, checkout with pendingTypes in pendingTypes; otherwise, checkout
   *         with pendingTypes added to lineItemTypes.
   */
  def withAdditionalTypes(newTypes: LineItemTypes) = {
    if (isTransacted) {
      this.copy(pendingTypes = newTypes ++ pendingTypes)

    } else {
      this.copy(_typesOrItems = Left(pendingTypes ++ lineItemTypes))

    }
  }



  /**
   * TODO(SER-499): work out customer details
   *
   * Persists this checkout, its types, and its items
   * @return PersistedCheckout of the transacted checkout
   */
  def transact(cashTransactionType: CashTransactionLineItemType): FailureOrCheckout = {
    if (isTransacted) {
      updateTransaction(cashTransactionType)

    } else {
      saveTransaction(cashTransactionType)

    }
  }




  /**
   * Makes a charge through the provided cash transaction information and persists all line items and
   * types as necessary. Makes sure not to charge customer if an error occurs in which the checkout
   * cannot be persisted.
   *
   * @param cashTransactionType cash transaction to pay for checkout
   * @return Transacted checkout or failure
   */
  protected def saveTransaction(cashTransactionType: CashTransactionLineItemType): FailureOrCheckout = {
    // NOTE(SER-499): not going to rollback checkout entity on transaction failure for now to make it easy to check for number of failure case by querying for checkout entities with no corresponding line item entities
    val savedCheckout = this.insert()

    val conn = services.currentTxnConnectionFactory()
    val savepoint = conn.setSavepoint()

    // get cash transaction line item with charge
    val cashTransactionItem = cashTransactionType.lineItems(lineItems) match {
      case Some(Seq(txnItem: CashTransactionLineItem)) =>
        txnItem.makeCharge(savedCheckout)

      case Some(txns: LineItems) =>
        // precaution against runtime errors from type erasure; make sure items passed to failure are actually txns
        val actualTxns = txns.flatMap(item => item.asCodeTypeOption(CodeType.CashTransaction))
        return Left(CheckoutFailedMultiplePaymentsResolved(this, actualTxns))

      case _ =>
        return Left(CheckoutFailedCashTransactionResolutionError(this, cashTransactionType))
    }


    // TODO(SER-499): wrap in transaction, currently doesn't roll back lineitems or domain objects...
    // transact line items
    val savedItems: LineItems = try {
      (cashTransactionItem +: savedCheckout.lineItems)
        .map { _.transact(savedCheckout) }

    } catch {
      // NOTE: checkout entity remains in DB for now after failure, but checkout entity alone is inconsequential

      case e: InsufficientInventoryException =>
        conn.rollback(savepoint)
        return Left(CheckoutFailedInsufficientInventory(this, cashTransactionItem, cashTransactionItem.abortTransaction()))

      case e: Exception =>
        conn.rollback(savepoint)
        /* DEBUG */ println("**CHECKOUT ERROR: " + e) /* END DEBUG */
        return Left(CheckoutFailedError(this, cashTransactionItem, cashTransactionItem.abortTransaction()))

    }



    // Note that reconstructing the checkout, instead of copying, updates total and subtotal
    Right( Checkout(savedCheckout._entity, savedItems) )
  }







  /**
   * Updates an existing checkout and its contents.
   * - intend to use original tax rates at the point of purchase for now
   *   * if updates happen after tax changes, calculated taxes will not match taxes of newly made purchase
   * - should refund taxes
   * - TODO: should not refund fees (e.g. shipping)
   *
   * @return Updated checkout or failure
   */
  protected def updateTransaction(cashTransactionType: CashTransactionLineItemType): FailureOrCheckout = {

    if (pendingTypes.isEmpty) {
      Right(this) // NOTE(SER-499): doesn't touch updated timestamp, is that okay?

    } else {
      /**
       * Update flow:
       * 1. Get the differences between previously transacted items and updated items
       * 2. Collect and transact items from pendingTypes and newly generated items (ex: taxes and
       *    fees of non-zero differences from previous transaction)
       * 3. Return checkout with no pendingTypes, just all transacted line items
       */

      /** transact items from pendingTypes and new taxes, fees, etc associated with them */
      _typesOrItems match {
        case Right(alreadyTransactedItems: LineItems) =>
          // TODO(SER-499): set db savepoints
          // TODO(SER-499): require sum of amounts is zero
          // TODO(SER-499): charge/refund the balance to cashTransactionType's item

          val updatedLineItems = pendingItems.map( item => item.transact(this) ) ++ alreadyTransactedItems

          Right(
            Checkout(_entity, updatedLineItems).update()
          )

        case _ => Left(CheckoutFailedUpdatedUnpersistedError(this, cashTransactionType))
      }

    }
  }





  protected def resolveTypes(types: LineItemTypes, preexistingItems: LineItems = Seq()) = {

    case class ResolutionPass(resolved: LineItems = preexistingItems, unresolved: LineItemTypes) {
      def execute: ResolutionPass = {
        /**
         * Iterates over unresolved in linear time on average (only counting iteration time)
         *
         * @param acc - accumulator of line items, should include previously resolved
         * @param before - item types preceding current type in iteration from list of all types
         * @param curr - current line item type being iterated over
         * @param after - remaining line item types to be iterated over
         * @return - ResolutionPass of resulting resolved items and unresolved types
         */
        def iterate(acc: LineItems = resolved)(
          before: LineItemTypes = Nil,
          curr: LineItemType[_] = unresolved.head,
          after: LineItemTypes = unresolved.tail
          ): ResolutionPass = (after, curr.lineItems(acc, before ++ after)) match {
          case (Nil, None) => ResolutionPass(acc, curr +: before)
          case (Nil, Some(res)) => ResolutionPass(res ++ acc,  before)
          case (next :: rest, None) => iterate(acc)(curr +: before, next, rest)
          case (next :: rest, Some(res)) => iterate(res ++ acc)( before, next, rest)
        }

        if (unresolved.isEmpty) this  // no additional to resolve
        else iterate()()              // iterate over unresolved
      }

      override def equals(that: Any) = that match {
        case ResolutionPass(thoseResolved, thoseUnresolved) =>
          (resolved.length, unresolved.length) == (thoseResolved.length, thoseUnresolved.length)
        case _ => false
      }
    }

    var i: Int = 0
    def resolve(pass: ResolutionPass): LineItems = {
      pass.execute match {
        case ResolutionPass(allItems, Nil) => allItems
        case unchangedPass if (unchangedPass == pass) =>
          throw new Exception("Failed to resolve line items, circular dependency detected.")
        case intermediatePass => resolve(intermediatePass)
      }
    }

    resolve(ResolutionPass(unresolved = types))
  }


  //
  // utility members
  //
  def isTransacted = id > 0 // could also do _typesOrItems.isRight

  lazy val account = customer.account
  lazy val addresses = account.addresses

  def customerId = _entity.customerId

  def total: TotalLineItem = lineItems.totalOption.get
  def subtotal: SubtotalLineItem = lineItems.subtotalOption.get
  def taxes: Seq[TaxLineItem] = lineItems.taxes
  def fees: LineItems = lineItems.fees
  def payments: LineItems = lineItems.payments
  def balance: Money = pendingItems.totalOption.get.amount minus total.amount


  def flattenLineItems: LineItems = {
    for (lineItem <- lineItems; flattened <- lineItem.flatten) yield flattened
  }

}




object Checkout extends Logging {

  // Create
  def apply(types: LineItemTypes, zipcode: String, maybeCustomer: Option[Customer]) = {
    val maybeZipcode = if (zipcode.isEmpty) None else Some(zipcode)
    val typesSansOldSummaries = types.filter(itemType => itemType.nature != LineItemNature.Summary)
    val typesWithTaxesAndSummaries = typesSansOldSummaries ++ taxesAndSummariesByZip(maybeZipcode)

    new Checkout(
      _entity = new CheckoutEntity(customerId = maybeCustomer.map(_.id).getOrElse(0)),
      _typesOrItems = Left(typesWithTaxesAndSummaries),
      _customer = maybeCustomer
    )
  }

  // Restore
  def apply(entity: CheckoutEntity, items: LineItems) = {
    new Checkout(
      _entity = entity,
      _typesOrItems = Right(itemsWithSummaries(items)),
      _customer = None
    )
  }


  /**
   * Helper for generating taxes and summaries.
   * TODO: add fees, such as shipping, later.
   *
   * @param maybeZipcode - None defaults to no taxes
   * @return Sequence of subtotal, taxes, and total (in that order)
   */
  protected def taxesAndSummariesByZip(maybeZipcode: Option[String]): LineItemTypes = {
    Seq(SubtotalLineItemType) ++
      TaxLineItemType.getTaxesByZip(maybeZipcode.getOrElse(TaxLineItemType.noZipcode)) ++
      Seq(TotalLineItemType)
  }

  protected def itemsWithSummaries(items: LineItems): LineItems = {
    val nonSummaries = items.filter (item => item.nature != LineItemNature.Summary )
    val subtotal = SubtotalLineItemType.lineItems(nonSummaries, Seq()).get.head // lol
    val total = TotalLineItemType.lineItems(nonSummaries, Seq()).get.head       // lololol

    subtotal +: (total +: nonSummaries)
  }



  //
  // Checkout failure cases
  //
  sealed abstract class CheckoutFailed(val failedCheckoutData: FailedCheckoutData)
  protected[checkout] trait FailedCheckoutWithCharge { def maybeCharge: Option[Charge] }

  case class CheckoutFailedCashTransactionResolutionError(
    checkout: Checkout,
    cashTransactionType: CashTransactionLineItemType
  ) extends CheckoutFailed(FailedCheckoutData(checkout, Seq(cashTransactionType)))

  case class CheckoutFailedInsufficientInventory(
    checkout: Checkout,
    canceledTransactionItem: CashTransactionLineItem,
    maybeCharge: Option[Charge]
  ) extends CheckoutFailed(
    FailedCheckoutData(checkout, Seq(canceledTransactionItem.itemType), Seq(canceledTransactionItem))
  ) with FailedCheckoutWithCharge

  case class CheckoutFailedMultiplePaymentsResolved(
    checkout: Checkout,
    cashTransactionItems: Seq[CashTransactionLineItem]
  ) extends CheckoutFailed(
    FailedCheckoutData(checkout, cashTransactionItems.map(_.itemType), cashTransactionItems)
  )

  case class CheckoutFailedError(
    checkout: Checkout,
    canceledTransactionItem: CashTransactionLineItem,
    maybeCharge: Option[Charge]
  ) extends CheckoutFailed(
    FailedCheckoutData(checkout, Seq(canceledTransactionItem.itemType), Seq(canceledTransactionItem))
  ) with FailedCheckoutWithCharge

  case class CheckoutFailedUpdatedUnpersistedError(
    checkout: Checkout,
    cashTransactionType: CashTransactionLineItemType
  ) extends CheckoutFailed(FailedCheckoutData(checkout, Seq(cashTransactionType)))

}

// TODO(SER-499): move me to another file, add persistance and functionality
case class FailedCheckoutData(
  checkout: Checkout,
  cashTransactionLineItemTypes: Seq[CashTransactionLineItemType] = Nil,
  cashTransactionLineItems: Seq[CashTransactionLineItem] = Nil,
  maybeTempCheckout: Option[Checkout] = None
)


