package models.checkout



import org.joda.money.{CurrencyUnit, Money}
import models.enums._
import org.squeryl.PrimitiveTypeMode._
import java.sql.Timestamp
import services.{AppConfig, Time}
import services.db._
import models._
import com.google.inject.Inject
import services.logging.Logging
import scala.Left
import scala.Some
import scala.Right
import exception.InsufficientInventoryException


// NOTE(SER-499): CashTransaction sets convention that payments to us are positive

/**
 * TODO: Refunds
 * -implement a product refund type and item for the purpose of canceling out its targetted
 *  item or type in the calculation of new totals (e.g. #1 above)
 *   -refunding tax could be separate or combined into product's refund amount
 * -implement a refund charge type to represent the credit made back to the customer
 */

// TODO(SER-499): most of this should not remain in pull request, just here for keeping track of noise generated by design
package object checkout {
  /** For _domainEntityId if domain object doesn't get persisted; ex: Tax */
  val UnusedDomainEntity: Long = -1

  /** For id's of line items and line item types that don't get persisted; ex: Subtotal */
  val Unpersisted: Long = -2

  val UnsavedEntity = 0

  type LineItems = Seq[LineItem[_]]
  type LineItemTypes = Seq[LineItemType[_]]
}

import models.checkout.checkout._



// TODO(SER-499): look into why store isn't usually combined into services (modeling concern probs)
//
// Services
//
case class CheckoutServices @Inject() (
  schema: Schema,
  lineItemStore: LineItemStore,
  customerStore: CustomerStore,
  accountStore: AccountStore,
  addressStore: AddressStore,
  dbSession: DBSession
) extends InsertsAndUpdatesAsEntity[Checkout, CheckoutEntity]
  with SavesCreatedUpdated[CheckoutEntity]
{

  override protected def table = schema.checkouts

  override def modelWithNewEntity(checkout: Checkout, entity: CheckoutEntity) = checkout.copy(entity)

  override def withCreatedUpdated(toUpdate: CheckoutEntity, created: Timestamp, updated: Timestamp) = {
    toUpdate.copy(created=created, updated=updated)
  }

  def findById(id: Long): Option[Checkout] = table.lookup(id).map { entity =>
    Checkout(entity, lineItemStore.getItemsByCheckoutId(entity.id))
  }

  def getCheckoutsByCustomerId(id: Long): Seq[Checkout] = {
    val checkouts = for (
      checkoutEntity <- table.where(entity => entity.customerId === id);
      checkout <- findById(checkoutEntity.id)
    ) yield checkout

    checkouts.toSeq
  }
}






//
// Model
//
case class Checkout (
  _entity: CheckoutEntity,
  _typesOrItems: Either[LineItemTypes, LineItems],
  _customer: Option[Customer],
  _additionalTypes: LineItemTypes = Nil,
  services: CheckoutServices = AppConfig.instance[CheckoutServices]
) extends HasEntity[CheckoutEntity, Long]
  with CanInsertAndUpdateAsThroughServices[Checkout, CheckoutEntity]
{
  import Checkout._

  //
  // Checkout members
  //
  lazy val lineItems: LineItems =  _typesOrItems match {
    case Right(items: LineItems) => resolveTypes(_additionalTypes, items)
    case Left(types: LineItemTypes) => resolveTypes(types)
  }

  lazy val lineItemTypes: LineItemTypes = _typesOrItems match {
    case Left(types: LineItemTypes) => types
    case Right(items: LineItems) => _additionalTypes ++ items.map(_.itemType)
  }

  lazy val customer: Customer = _customer.getOrElse(
    services.customerStore.findById(customerId).getOrElse(
      throw new IllegalArgumentException("No customer associated with this checkout.")
    )
  )



  /**
   * Adds unpersisted types to a persisted checkout (to queue up for an update) or adds to other
   * types in an unpersisted checkout.
   *
   * @param additionalTypes -- to be added to this checkout
   * @return If transacted, checkout with additionalTypes in _additionalTypes; otherwise, checkout
   *         with _additionalTypes added to lineItemTypes.
   */
  def withAdditionalTypes(additionalTypes: LineItemTypes) = {
    if (isPersisted) {
      this.copy(_additionalTypes = additionalTypes ++ _additionalTypes)
    } else {
      this.copy(_typesOrItems = Left(additionalTypes ++ lineItemTypes))
    }
  }

  /**
   * TODO(SER-499): work out customer details
   *
   * Persists this checkout, its types, and its items
   * @return PersistedCheckout of the transacted checkout
   */
  def transact(
    cashTransactionType: CashTransactionLineItemType //,customer: Option[Customer]
  ): Either[CheckoutFailed, Checkout] = {
    

    // TODO(SER-499): require payment/sum of [products, fees, taxes]/total and charges to be zero.
    // TODO(SER-499): make transact take checkout context
    if (isPersisted) {
      updateTransaction(cashTransactionType)

    } else {

      // get cash transaction line item with charge
      val cashTransactionItem = cashTransactionType.lineItems(lineItems) match {
        case Some((txnItem: CashTransactionLineItem) :: _) => txnItem.makeCharge()
        // case Some(Nil) => // possible case for checkouts that don't need a cash transaction?
        case _ => return Left(CheckoutFailedCashTransactionResolutionError(this, cashTransactionType))
      }

      // transact everything
      val savedCheckout = this.insert()

      val savedItems: LineItems = (cashTransactionItem +: savedCheckout.lineItems).map { (item: LineItem[_]) =>
        try {
          item.transact(savedCheckout)
        } catch {

          // NOTE: checkout entity remains in DB for now after failure, but checkout entity alone is inconsequential
          // refund charge and return error case
          case e: InsufficientInventoryException => {
            return Left(CheckoutFailedInsufficientInventory(this, cashTransactionItem.abortTransaction()))
          }

          case e: Exception => {
            // DEBUG
            println("**CHECKOUT ERROR: " + e)


            return Left(CheckoutFailedError(this, cashTransactionItem.abortTransaction()))
          }
        }
      }

      // Note that reconstructing the checkout, instead of copying, updates total and subtotal
      Right( Checkout(savedCheckout._entity, savedItems) )
    }
  }



  /**
   * Updates an existing checkout and its contents.
   * - intend to use original tax rates at the point of purchase for now
   *   * if updates happen after tax changes, calculated taxes will not match taxes of newly made purchase
   * - should refund taxes
   * - TODO: should not refund fees (e.g. shipping)
   *
   * @return Updated checkout
   */
  protected def updateTransaction(cashTransactionType: CashTransactionLineItemType): Either[CheckoutFailed, Checkout] = {
    // TODO(SER-499): clean this whole bessy up
    if (_additionalTypes.isEmpty) {
      Right(this) // NOTE(SER-499): doesn't touch updated timestamp, is that okay?

    } else {
      import LineItemNature._

      def grossToNet(gross: LineItems, old: LineItems) = gross.flatMap { newItem =>
        val oldAmount = old.find(_.itemType == newItem.itemType).map(_.amount).getOrElse(Money.zero(CurrencyUnit.USD))

        if (oldAmount isGreaterThan newItem.amount) None
        else Some(newItem.withAmount(newItem.amount minus oldAmount))
      }

      def replaceItems(oldItems: LineItems, replacementItems: LineItems) =
        replacementItems.foldLeft(oldItems){ (itemsAcc, nextReplacementItem) =>
          itemsAcc.updated(
            itemsAcc.indexWhere(item => item.itemType == nextReplacementItem.itemType),
            nextReplacementItem
          )
        }

      /**
       * Need to:
       * 1. Get the new taxes, fees, total as the difference between what a fresh checkout with all
       *    of this carts line item types produces and the ones that already exist in this checkout
       * 2. Collect and transact items from _additionalTypes and the new taxes and fees
       * 3. Return checkout with no _additionalTypes, just transacted line items
       *
       * - make sure not to try to get the newly created items (from _additionalTypes) from the
       *   tempCheckout because all its lineItems will appear unpersisted (since they are, technically)
       */

      val oldTaxes = lineItemsOfNature(Tax)
      val oldFees = lineItemsOfNature(Fee)

      /** calculate new fees, taxes, total */
      // Has all tax, fee, & summary types, will apply them to entire checkout
      val tempCheckout = new Checkout(
        _entity = CheckoutEntity(),
        _typesOrItems = Left(lineItemTypes),
        _customer = _customer
      )

      val grossNewTaxes = tempCheckout.lineItemsOfNature(Tax)
      val grossNewFees = tempCheckout.lineItemsOfNature(Fee)
      val netNewTaxes = grossToNet(grossNewTaxes, oldTaxes)
      val netNewFees = grossToNet(grossNewFees, oldFees)
      val newItems = netNewTaxes ++ netNewFees ++ lineItems.filter(item => _additionalTypes.contains(item.itemType))


      // TODO(SER-499): replace with CheckoutFailed's
      assert(netNewTaxes.map(item => item.itemType).toSet.size == netNewTaxes.size, "There should be no duplicate taxes.")
      assert(netNewFees.map(item => item.itemType).toSet.size == netNewFees.size, "There should be no duplicate fees.")


      /** transact items from _additionalTypes and new taxes, fees, etc associated with them */
      _typesOrItems match {
        case Right(alreadyTransactedItems: LineItems) =>
          // TODO(SER-499): require sum of amounts is zero
          val newItemsTransacted = newItems.map( item => item.transact(this) )

          val updatedLineItems = newItemsTransacted ++
            replaceItems(alreadyTransactedItems, Seq(tempCheckout.subtotal, tempCheckout.total))

          Right(
            this.copy(
              _typesOrItems = Right(updatedLineItems),
              _additionalTypes = Nil
            ).update()
          )

        case _ => Left(CheckoutFailedUpdatedUnpersistedError(this, cashTransactionType))
      }

    }
  }


  //
  // utility members
  //
  lazy val account = customer.account
  lazy val addresses = account.addresses
  def customerId = _entity.customerId

  def subtotal: SubtotalLineItem = lineItemsOfCodeType(CodeType.Subtotal).head
  def total: TotalLineItem = lineItemsOfCodeType(CodeType.Total).head

  def flattenLineItems: LineItems = {
    for (lineItem <- lineItems; flattened <- lineItem.flatten) yield flattened
  }

  def lineItemsOfCodeType[ LIT <: LineItemType[_], LI  <: LineItem[_] ] (codeType: CodeTypeFactory[LIT, LI]): Seq[LI] = {
    for (item <- lineItems if item.codeType == codeType) yield item.asInstanceOf[LI]
  }

  def lineItemsOfNature(nature: LineItemNature) = lineItems.filter(_.nature == nature)

  protected def resolveTypes(types: LineItemTypes, preexistingItems: LineItems = Seq()) = {

    case class ResolutionPass(resolved: LineItems = preexistingItems, unresolved: LineItemTypes) {
      def execute: ResolutionPass = {
        /**
         * Iterates over unresolved in linear time on average (only counting iteration time)
         *
         * @param acc - accumulator of line items, should include previously resolved
         * @param before - item types preceding current type in iteration from list of all types
         * @param curr - current line item type being iterated over
         * @param after - remaining line item types to be iterated over
         * @return - ResolutionPass of resulting resolved items and unresolved types
         */
        def iterate(acc: LineItems = resolved)(
          before: LineItemTypes = Nil,
          curr: LineItemType[_] = unresolved.head,
          after: LineItemTypes = unresolved.tail
        ): ResolutionPass = (after, curr.lineItems(acc, before ++ after)) match {
          case (Nil, None) => ResolutionPass(acc, curr +: before)
          case (Nil, Some(res)) => ResolutionPass(res ++ acc,  before)
          case (next :: rest, None) => iterate(acc)(curr +: before, next, rest)
          case (next :: rest, Some(res)) => iterate(res ++ acc)( before, next, rest)
        }

        if (unresolved.isEmpty) this  // no additional to resolve
        else iterate()()              // iterate over unresolved
      }

      override def equals(that: Any) = that match {
        case ResolutionPass(thoseResolved, thoseUnresolved) =>
          (resolved.length, unresolved.length) == (thoseResolved.length, thoseUnresolved.length)
        case _ => false
      }
    }

    var i: Int = 0
    def resolve(pass: ResolutionPass): LineItems = {
      pass.execute match {
        case ResolutionPass(allItems, Nil) => allItems
        case unchangedPass if (unchangedPass == pass) =>
          throw new Exception("Failed to resolve line items, circular dependency detected.")
        case intermediatePass => resolve(intermediatePass)
      }
    }

    resolve(ResolutionPass(unresolved = types))
  }
}




object Checkout extends Logging {

  // Create
  def apply(types: LineItemTypes, zipcode: String, maybeCustomer: Option[Customer]) = {
    val maybeZipcode = if (zipcode.isEmpty) None else Some(zipcode)
    val typesSansOldSummaries = types.filter(itemType => itemType.nature != LineItemNature.Summary)
    val typesWithTaxesAndSummaries = typesSansOldSummaries ++ taxesAndSummariesByZip(maybeZipcode)

    new Checkout(
      _entity = new CheckoutEntity(customerId = maybeCustomer.map(_.id).getOrElse(0)),
      _typesOrItems = Left(typesWithTaxesAndSummaries),
      _customer = maybeCustomer
    )
  }

  // Restore
  def apply(entity: CheckoutEntity, items: LineItems) = {
    new Checkout(
      _entity = entity,
      _typesOrItems = Right(itemsWithSummaries(items)),
      _customer = None
    )
  }


  /**
   * Helper for generating taxes and summaries.
   * TODO: add fees, such as shipping, later.
   *
   * @param maybeZipcode - None defaults to no taxes
   * @return Sequence of subtotal, taxes, and total (in that order)
   */
  protected def taxesAndSummariesByZip(maybeZipcode: Option[String]): LineItemTypes = {
    Seq(SubtotalLineItemType) ++
      TaxLineItemType.getTaxesByZip(maybeZipcode.getOrElse(TaxLineItemType.noZipcode)) ++
      Seq(TotalLineItemType)
  }

  protected def itemsWithSummaries(items: LineItems): LineItems = {
    val nonSummaries = items.filter (item => item.nature != LineItemNature.Summary )
    val subtotal = SubtotalLineItemType.lineItems(nonSummaries, Seq()).get.head // lol
    val total = TotalLineItemType.lineItems(nonSummaries, Seq()).get.head       // lololol

    subtotal +: (total +: nonSummaries)
  }



  //
  // Checkout failure cases
  //
  sealed abstract class CheckoutFailed(val failedCheckoutData: FailedCheckoutData)

  case class CheckoutFailedCashTransactionResolutionError(
    checkout: Checkout,
    cashTransactionType: CashTransactionLineItemType
  ) extends CheckoutFailed(FailedCheckoutData(checkout, cashTransactionType))

  case class CheckoutFailedInsufficientInventory(
    checkout: Checkout,
    canceledTransactionItem: CashTransactionLineItem
  ) extends CheckoutFailed(
    FailedCheckoutData(checkout, canceledTransactionItem.itemType, Some(canceledTransactionItem))
  )

  case class CheckoutFailedError(
    checkout: Checkout,
    canceledTransactionItem: CashTransactionLineItem
  ) extends CheckoutFailed(
    FailedCheckoutData(checkout, canceledTransactionItem.itemType, Some(canceledTransactionItem))
  )

  case class CheckoutFailedUpdatedUnpersistedError(
    checkout: Checkout,
    cashTransaction: CashTransactionLineItemType
  ) extends CheckoutFailed(FailedCheckoutData(checkout, cashTransaction))

}

// TODO(SER-499): move me to another file, add persistance and functionality
case class FailedCheckoutData(
  checkout: Checkout,
  cashTransactionLineItemType: CashTransactionLineItemType,
  maybeCashTransactionLineIte: Option[CashTransactionLineItem] = None
)


